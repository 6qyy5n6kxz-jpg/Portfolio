/* Global outline:
   - Load config.json
   - Try to load prebuilt manifest.json (generated by nightly action). If absent, build from Google Drive + AI locally.
   - Build filters (season, year, etc), render gallery, paginate, search.
*/
const state = {
  config: null,
  manifest: [],
  page: 1,
  pageSize: 60,
  index: null, // simple search index
  model: null, // mobilenet
};

const els = {
  title: document.getElementById('site-title'),
  search: document.getElementById('search'),
  season: document.getElementById('season-filter'),
  difficulty: document.getElementById('difficulty-filter'),
  orientation: document.getElementById('orientation-filter'),
  year: document.getElementById('year-filter'),
  color: document.getElementById('color-filter'),
  reset: document.getElementById('reset'),
  gallery: document.getElementById('gallery'),
  pagination: document.getElementById('pagination'),
};

const SEASONS = [
  { name: 'Winter', months: [12,1,2] },
  { name: 'Spring', months: [3,4,5] },
  { name: 'Summer', months: [6,7,8] },
  { name: 'Fall',   months: [9,10,11] },
];

function monthToSeason(m) {
  return SEASONS.find(s => s.months.includes(m))?.name ?? '';
}

function dominantColorClass(rgb=[128,128,128]) {
  const [r,g,b]=rgb;
  const max = Math.max(r,g,b);
  const min = Math.min(r,g,b);
  const cool = b>=g && b>=r;
  const warm = r>=g && r>=b;
  const neutral = (max-min)<30;
  if (neutral) return 'neutral';
  if (warm) return 'warm';
  if (cool) return 'cool';
  return 'neutral';
}

// crude "difficulty" heuristic: night/astro/macro/action/long-exposure increases difficulty
function inferDifficulty(tags=[]) {
  const t = new Set(tags.map(x=>x.toLowerCase()));
  const hardKeys = ['night','milky way','stars','macro','macro photography','action','sports','long exposure','light trails','underwater'];
  const moderateKeys = ['low light','wildlife','telephoto','waterfall','sunset','sunrise'];
  if (hardKeys.some(k=>t.has(k))) return 'hard';
  if (moderateKeys.some(k=>t.has(k))) return 'moderate';
  return 'easy';
}

async function loadConfig() {
  const res = await fetch('./public/config.json');
  const cfg = await res.json();
  state.config = cfg;
  state.pageSize = cfg.ITEMS_PER_PAGE ?? 60;
  document.title = cfg.SITE_TITLE || 'Portfolio';
  els.title.textContent = cfg.SITE_TITLE || 'Portfolio';
}

async function tryLoadPrebuiltManifest() {
  try {
    const res = await fetch('./public/manifest.json', { cache: 'no-store' });
    if (!res.ok) return null;
    return await res.json();
  } catch { return null; }
}

async function fetchDriveListPage(pageToken=null) {
  const { GOOGLE_DRIVE_FOLDER_ID, GOOGLE_API_KEY } = state.config;
  const q = encodeURIComponent(`'${GOOGLE_DRIVE_FOLDER_ID}' in parents and trashed=false and (mimeType contains 'image/')`);
  const url = new URL('https://www.googleapis.com/drive/v3/files');
  url.searchParams.set('q', q);
  url.searchParams.set('fields', 'files(id,name,mimeType,thumbnailLink,webViewLink,webContentLink,modifiedTime,createdTime,owners,md5Checksum),nextPageToken');
  url.searchParams.set('pageSize', '1000');
  if (pageToken) url.searchParams.set('pageToken', pageToken);
  url.searchParams.set('key', GOOGLE_API_KEY);
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error('Drive API error');
  return res.json();
}

async function fetchAllDriveFiles() {
  let out = [];
  let token = null;
  do {
    const page = await fetchDriveListPage(token);
    out = out.concat(page.files || []);
    token = page.nextPageToken || null;
  } while (token);
  return out;
}

function getSeasonYearFromDateStr(dstr) {
  if (!dstr) return { season: '', year: '' };
  const d = new Date(dstr);
  const season = monthToSeason(d.getUTCMonth()+1);
  return { season, year: String(d.getUTCFullYear()) };
}

// read EXIF (best-effort) from a Blob
async function readExif(blob) {
  try {
    const exif = await exifr.parse(blob, { tiff: true, exif: true, gps: true });
    return exif || {};
  } catch { return {}; }
}

function aspectToOrientation(w,h) {
  if (!w || !h) return '';
  const r = w/h;
  if (Math.abs(r-1) < 0.05) return 'square';
  return r >= 1 ? 'landscape' : 'portrait';
}

async function mobilenetTags(imgEl) {
  if (!state.model) {
    state.model = await mobilenet.load(); // small, fast
  }
  const preds = await state.model.classify(imgEl, 3);
  return preds.map(p => p.className.toLowerCase());
}

async function computeDominantColor(imgEl) {
  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  const ctx = c.getContext('2d');
  ctx.drawImage(imgEl, 0, 0, c.width, c.height);
  const data = ctx.getImageData(0,0,c.width,c.height).data;
  let r=0,g=0,b=0,count=0;
  for (let i=0;i<data.length;i+=4) { r+=data[i]; g+=data[i+1]; b+=data[i+2]; count++; }
  return [Math.round(r/count), Math.round(g/count), Math.round(b/count)];
}

async function buildManifestClient(files) {
  // Build manifest with: public URLs, EXIF (date, camera, width/height if present), AI tags, color, orientation, season/year
  const items = [];
  // process in small batches to avoid freezing
  for (const f of files) {
    // Prefer thumbnail for quick tag/color estimation
    const thumb = f.thumbnailLink?.replace('=s220','=s800') || null;
    const src = f.webContentLink ? `${f.webContentLink}&key=${state.config.GOOGLE_API_KEY}` : null;
    const url = thumb || src;
    if (!url) continue;

    // load image element
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = url;
    await new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=()=>res(); });

    // AI tags + color + EXIF
    let tags = [];
    if (state.config.ENABLE_CLIENT_AI_TAGGING) {
      try { tags = await mobilenetTags(img); } catch {}
    }
    let exif = {};
    try {
      // fetch small blob for EXIF where possible (photo original might be large; Drive may strip EXIF on thumbnail)
      if (src) {
        const b = await (await fetch(src)).blob();
        exif = await readExif(b);
      }
    } catch {}

    const width = img.naturalWidth, height = img.naturalHeight;
    const orient = aspectToOrientation(width, height);

    const rgb = await computeDominantColor(img);
    const colorClass = dominantColorClass(rgb);

    // season/year from EXIF date or Drive modifiedTime
    const dt = exif.DateTimeOriginal || exif.CreateDate || f.createdTime || f.modifiedTime;
    const { season, year } = getSeasonYearFromDateStr(dt);

    const camera = exif.Model || exif.Make || '';
    const lens = exif.LensModel || '';

    const difficulty = inferDifficulty(tags);

    items.push({
      id: f.id,
      name: f.name,
      src: src || url,
      view: f.webViewLink,
      tags,
      season, year, difficulty,
      orientation: orient,
      color: colorClass,
      camera, lens,
      width, height
    });
  }
  return items;
}

function buildFiltersFromManifest(manifest) {
  const years = [...new Set(manifest.map(m=>m.year).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
  els.year.innerHTML = '<option value="">Year</option>' + years.map(y=>`<option value="${y}">${y}</option>`).join('');
  const seasons = ['Winter','Spring','Summer','Fall'];
  els.season.innerHTML = '<option value="">Season</option>' + seasons.map(s=>`<option value="${s}">${s}</option>`).join('');
}

function itemMatchesFilters(it, q) {
  const txt = (it.name + ' ' + (it.tags||[]).join(' ') + ' ' + (it.camera||'') + ' ' + (it.lens||'')).toLowerCase();
  if (q.search && !txt.includes(q.search.toLowerCase())) return false;
  if (q.season && it.season !== q.season) return false;
  if (q.year && it.year !== q.year) return false;
  if (q.difficulty && it.difficulty !== q.difficulty) return false;
  if (q.orientation && it.orientation !== q.orientation) return false;
  if (q.color && it.color !== q.color) return false;
  return true;
}

function render(manifest) {
  // filters
  const q = {
    search: els.search.value.trim(),
    season: els.season.value,
    difficulty: els.difficulty.value,
    orientation: els.orientation.value,
    year: els.year.value,
    color: els.color.value,
  };
  const filtered = manifest.filter(it=>itemMatchesFilters(it, q));

  // paginate
  const pages = Math.max(1, Math.ceil(filtered.length / state.pageSize));
  if (state.page > pages) state.page = pages;
  const start = (state.page-1) * state.pageSize;
  const pageItems = filtered.slice(start, start + state.pageSize);

  // gallery
  els.gallery.innerHTML = pageItems.map(it=>`
    <div class="card">
      <a href="${it.view}" target="_blank" rel="noopener">
        <img loading="lazy" src="${it.src}" alt="${it.name}" />
      </a>
      <div class="meta">
        <div class="row">
          <span class="kv">${it.year || ''} ${it.season || ''}</span>
          <span class="kv">${it.orientation || ''} Â· ${it.color || ''}</span>
        </div>
        <div class="row">
          <span class="kv">${it.camera || ''}</span>
          <span class="kv">${it.difficulty || ''}</span>
        </div>
        <div class="tags">${
          (it.tags||[]).map(t=>`<span class="tag">${t}</span>`).join('')
        }</div>
      </div>
    </div>
  `).join('');

  // pagination
  els.pagination.innerHTML = `
    <button class="page-btn" ${state.page<=1?'disabled':''} data-go="prev">Prev</button>
    <span class="page-btn" disabled>Page ${state.page} / ${pages}</span>
    <button class="page-btn" ${state.page>=pages?'disabled':''} data-go="next">Next</button>
  `;
  els.pagination.querySelectorAll('.page-btn[data-go]').forEach(btn=>{
    btn.onclick = ()=>{
      const dir = btn.dataset.go;
      if (dir==='prev' && state.page>1) { state.page--; render(manifest); }
      if (dir==='next' && state.page<pages) { state.page++; render(manifest); }
    };
  });
}

async function init() {
  await loadConfig();

  // Build or load manifest
  let manifest = await tryLoadPrebuiltManifest();
  if (!manifest || !Array.isArray(manifest) || manifest.length === 0) {
    // fetch from Drive
    const files = await fetchAllDriveFiles();
    manifest = await buildManifestClient(files);
    // cache to localStorage for speed next time (user device only)
    try { localStorage.setItem('portfolio_manifest_cache', JSON.stringify(manifest)); } catch {}
  }
  state.manifest = manifest;

  buildFiltersFromManifest(manifest);

  // Bind UI
  [els.search, els.season, els.difficulty, els.orientation, els.year, els.color].forEach(el=>{
    el.oninput = ()=>{ state.page=1; render(state.manifest); };
    el.onchange = ()=>{ state.page=1; render(state.manifest); };
  });
  els.reset.onclick = ()=>{
    els.search.value=''; els.season.value=''; els.difficulty.value=''; els.orientation.value=''; els.year.value=''; els.color.value='';
    state.page=1; render(state.manifest);
  };

  render(state.manifest);
}

init().catch(err=>{
  console.error(err);
  els.title.textContent = 'Portfolio (error loading)';
});
